"""
R version documentation from https://github.com/broadinstitute/gsalib/blob/master/man/gsa.reshape.concordance.table.Rd

\name{gsa.reshape.concordance.table}
\alias{gsa.reshape.concordance.table}
\title{
Reshape a Concordance Table
}
\description{
Given a GATKReport generated by GenotypeConcordance (as output by \code{gsa.read.gatkreport}), this function reshapes the concordance for a specified sample into a matrix with the EvalGenotypes in rows and the CompGenotypes in columns (see the documentation for GenotypeConcordance for the definition of Eval and Comp)
}
\usage{
gsa.reshape.concordance.table(report, table.name="GenotypeConcordance_Counts", sample.name="ALL")
}
\arguments{
  \item{report}{
A GATKReport as output by \code{gsa.read.gatkreport}.  If \code{table.name} is \code{NULL}, \code{report} is assumed to be the vector of concordance values to reshape.
}
  \item{table.name}{
The table name in the GATKReport to reshape.  Defaults to "GenotypeConcordance_Counts", but could also be one of the proportion tables ("GenotypeConcordance_EvalProportions", "GenotypeConcordance_CompProportions").  This value can also be \code{NULL}, in which case \code{report} is reshaped directly.
}
  \item{sample.name}{
The sample name within \code{table.name} to use.
}
}
\value{
Returns a two-dimensional matrix with Eval genotypes in the rows and Comp genotypes in the columns.  The genotypes themselves (\code{HOM_REF}, \code{NO_CALL}, etc) are specified in the row/col names of the matrix.
}
\author{
Phillip Dexheimer
}

\seealso{
\code{\link{gsa.read.gatkreport}}
}
\examples{
test_file = system.file("extdata", "test_genconcord.table", package = "gsalib")
report = gsa.read.gatkreport(test_file)
gsa.reshape.concordance.table(report)

## Output looks like:
##              CompGenotypes
##EvalGenotypes NO_CALL HOM_REF HET HOM_VAR UNAVAILABLE MIXED
##  NO_CALL     0       0       0       0       0           0
##  HOM_REF     0       0       0       0       0           0
##  HET         0       0       13463   90      3901        0
##  HOM_VAR     0       0       2935    18144   4448        0
##  UNAVAILABLE 0       0       2053693 1326112 11290       0
##  MIXED       0       0       0       0       0           0
}
\keyword{ manip }

Python version output looks like:
CompGenotypes   NO_CALL  HOM_REF      HET  HOM_VAR  UNAVAILABLE  MIXED
EvalGenotypes
      NO_CALL         0        0        0        0            0      0
      HOM_REF         0        0        0        0            0      0
          HET         0        0    13463       90         3901      0
      HOM_VAR         0        0     2935    18144         4448      0
  UNAVAILABLE         0        0  2053693  1326112        11290      0
        MIXED         0        0        0        0            0      0
"""

# from itertools import product
import pandas as pd
import gsalib


def reshape_concordance_table(report, table_name="GenotypeConcordance_Counts", sample_name="ALL"):
    """
    Given a GATKReport generated by GenotypeConcordance (as output by \code{gsa.read.gatkreport}),
    this function reshapes the concordance for a specified sample into a matrix
    with the EvalGenotypes in rows and the CompGenotypes in columns
    (see the documentation for GenotypeConcordance for the definition of Eval and Comp)
    :param report: a GatkReport object
    :param table_name: the name of a table in the report
    :param sample_name: the name of a sample in the table ( or  'ALL')
    :return: a DataFrame of eval/comp counts, indexed by EvalGenotypes, and columns of CompGenotypes
    """
    if table_name is not None:
        data = report[table_name]
    else:
        return None

    # the genotypes of interest, based on the table's column names,
    # which have the form eval_genotype_comp_genotype
    # ignoring columns Sample and Mismatching_Alleles, and maybe others
    possible_genotypes = ['NO_CALL', 'HOM_REF', 'HET', 'HOM_VAR', 'UNAVAILABLE', 'MIXED']

    # transpose the table into a 1-column DataFrame indexed by eval_genotype_comp_genotype strings
    d = data.loc[data['Sample'] == sample_name].T
    # create a list of the genotype counts ordered by eval, comp
    m = []
    for eval_genotype in possible_genotypes:
        eval_df = d[d.index.str.startswith(eval_genotype)]
        for comp_genotype in possible_genotypes:
            comp_df = eval_df[eval_df.index.str.endswith(comp_genotype)]
            m.append(comp_df.values[0][0])
    # create a matrix-like Series with comp
    s = pd.Series(m).reshape(len(possible_genotypes), len(possible_genotypes))
    df = pd.DataFrame(s, columns=possible_genotypes, index=possible_genotypes).rename_axis(
        'EvalGenotypes').rename_axis("CompGenotypes", axis="columns")

    # FYI other stuff that can be done
    # these are the possible names of the columns in the form {eval}_{comp}
    # any other columns, such as 'Sample' and 'Mismatching_Alleles' will be dropped
    # {genotype_combination: (eval, comp,), ...}
    # genotype_dict = {'_'.join(g): g for g in product(possible_genotypes, possible_genotypes)}
    # replace 'eval_comp' string index with (eval,comp) tuples
    # tuple_indexed_d = d.drop([i for i in d.index if i not in genotype_dict.keys()], axis=0)
    # tuple_indexed_d.index = [genotype_dict[i] for i in tuple_indexed_d.index]

    # select a row with the tuple index in a list, as
    # d.loc[[('HET', 'HET')]]

    # the next two examples assume that the original order of the table follows the order of possible_genotypes
    # multi_indexed_d = d.set_index(pd.MultiIndex.from_product(
    #     [possible_genotypes, possible_genotypes], names=('eval', 'comp')))
    #
    # matrix_like_d = pd.DataFrame(d.values.reshape(
    #     len(possible_genotypes), len(possible_genotypes)), columns=possible_genotypes, index=possible_genotypes)

    return df
